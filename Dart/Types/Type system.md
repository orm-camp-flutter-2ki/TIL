# Type system
[공식문서](https://dart.dev/language/type-system) 

Dart는 정적 타입 체크와 런타임 타입 체크를 통해 변수의 값이 변수의 타입과 항상 일치하도록 보장한다. (이를 sound typing이라고도 함) 

또한, 타입 추론을 통해 명시적으로 타입을 지정해야하는 번거로움도 줄였다.

Dart의 static analyzer를 통해 정적 타입 체크로 컴파일 타입에 버그를 찾을 수 있다.

## Soundness
Soundness는 프로그램으로 하여금 유효하지 않은 특정 상태로 들어가지 않도록 보장하는 것이다.  

Sound 타입 시스템은 표현식의 결과 값이 표현식의 정적 타입과 맞지 않는 상황이 발생할 수 없다. (String에는 String 값만 할당 가능)  

Soundness는 아래의 두가지 체크의 조합이다.  
- 컴파일 타임 체크: 타입과 값이 일치하지 않는 할당을 에러 처리  
- 런타임 체크: 일치하지 않는 타입으로의 캐스팅을 에러 처리

<br>

### Soundness의 이점
- 타입 관련 버그를 컴파일 타임에 체크
- 코드의 가독성과 유지보수성 향상
- 더 나은 AOT 컴파일

<br>

### 정적 타입 분석의 권고사항
- 부모 메서드를 오버라이드하는 경우, 메서드의 반환 타입은 부모 메서드의 반환 타입의 하위(<=) 타입이어야 한다.
- 부모 메서드를 오버라이드 하는 경우, 메서드 파라미터의 타입은 부모 메서드의 파라미터 타입의 상위(>=) 타입이어야 한다.  
(하위 타입이어도 되는 유효한 근거가 있다면 `covariant` 키워드를 통해 공변성을 적용할 수 있다.)
- 하나의 타입을 갖는 값으로 이루어진 list에 `dynamic`을 사용하면 안된다.  
    => 타입을 지정할 것, ~~`dynamic`은 그냥 사용하지 말 것~~

<br>

## Type 추론
Dart는 필드, 메서드, 지역 변수, 대부분의 제네릭 타입 인자에 대해 타입 추론을 지원한다. (타입에 대한 충분한 정보가 없는 경우 `dynamic`으로 추론, ~~하지만 최대한 안전한 방향으로 추론을 해줄려고 노력하는 착한 친구~~)  

<br>

### 필드/메서드 추론
- 부모의 필드/메서드를 오버라이드한 필드/메서드는 타입이 지정되지 않아도 부모의 타입에 의해 타입이 추론된다.
- 일반적인 필드/메서드는 초기화 값을 통해 타입이 추론된다.

<br>

### Static 필드 추론
- 정적 필드/변수는 초기화 값에 의해 타입이 추론된다.  
    => 변수의 타입을 알아야지만 변수의 타입 추론이 가능한 경우는 타입 추론에 실패

<br>

### 지역 변수 추론
- 지역 변수는 초기화 값에 의해 타입이 추론된다.     
    => 초기화 이후의 할당되는 값은 추론에 영향을 주지 않는다.
    (이로 인해, 너무 구체적인 타입이 추론될 수 있음에 유의)

<br>

### 타입 인자 추론
- 생성자/제네릭메서드 호출에 대한 타입은 호출이 일어나는 문맥에서의 하한 정보와 생성자/제네릭메서드 인자에서의 상한 정보의 조합으로 추론된다.  
    => 추론된 타입이 의도와 다른 경우, 타입을 명시할 것

## 타입 대체
메서드 오버라이드, 제네릭 메서드 본문에서의 타입 대체는 다음의 규칙을 기반으로 한다.
> 소비자(consumer)의 타입은 상위 타입으로 생산자(producer)의 타입은 하위 타입으로 대체할 수 있다.  

=> 변수 할당에서 값을 넘기는 쪽이 생산자, 값을 받는 쪽이 소비자  
=> 인자를 받지만 리턴 값이 없는 메서드는 소비자  
=> 리턴 값이 있는 메서드는 생산자  

