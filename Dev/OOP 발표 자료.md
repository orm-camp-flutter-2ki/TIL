# 객체지향

### 객체지향이란?

블럭, 조립 로봇처럼 코딩

### ‘왜’ 필요한가?

- 비용
    
    새로운 코드 생성, 코드 추가, 코드 삭제 , 코드 수정
    
- 직관적인 이해

### 객체지향 설계?

- 협력과 메세지
- **역할/책임 = 타입 (→ 다형성)**
- 행위/상태


### 완성도 높은 OOP란?

**객체가 충분히 자율적인 동시에 충분히 협력적인**

다른 객체와 충분히 조화롭게 협력할 수 있을 만큼 충분히 **개방적**인 동시에 협력에 참여하는 방법을 스스로 결정할 수 있을 만큼 충분히 **자율적**인 객체들의 공동체를 설계하는 것

### 검증 방법, 설계 방법

왜를 반대로 생각해볼 것

<br>

# 캡슐화

**하나의 목적을 위해 필요한 데이터나 메소드를 하나로 묶는 것**

**객체의 상태(데이터, 속성)를 숨기고 행위(메서드)만 노출하는 것**

### ~~vs 정보은닉, 은닉화~~

- ~~데이터 보안~~
- ~~데이터 불변~~

### 목적, 왜?

- 협력을 **단순**하고 **유연**하게
- 수정의 비용 감소 (→ 다형성)


물론 예외는 있음  
프로퍼티가 행위의 일부 = 데이터클래스

<br>

# 추상화

**객체의 공통의 속성이나 행위를 묶는 것**

프로그래밍보다는 설계의 이야기

### 목적, 왜?

역할의 정의 → **타입 계층 구축**

공통점을 모아서 중복되는 코드(중복 코드 작성) 피하기

### 추상화 방법

- 추상 클래스(abstract class)
    
    같은 혈통, 신분
    
    ⇒ 공통 속성, 메서드
    
- 인터페이스(interface)
    
    같은 행위
    
    ⇒ 필수적인 행위
    

<br>

# 상속

**메소드와 변수를 물려받되, 필요한 기능을 더 추가하거나 나에게 맞게 재정의하는 것**

### 목적, 왜?

- 추상클래스 상속
    
    공통 속성, 메서드 재사용 = 같은 타입 (→ 다형성)
    
    기능 확장(다른 것만 커스텀)
    
- 인터페이스 상속 (구현)
    
    같은 동작을 수행함을 보장 (→ 다형성)
    

~~(물론 기본적으로 코드 재작성을 피할 수 있음)~~

추상화와 상속 예제로 정리

Starcraft → team 비교 (Marine, Medic     SCV)

<br>

# 다형성

**하나의 요소(객체, 메서드)가 다양한 형식에 속할 수 있는 것**

하나의 객체가 여러 가지 타입을 가질 수 있는 것 → 타입 캐스팅

### 목적, 왜?

- 객체들의 **대체 가능성**을 이용해 설계를 **유연하고 재사용 가능**하게 만든다.
    
    하나의 타입에 여러 객체
    
    하나의 객체가 여러 타입
    
- 객체의 자율성 증가(메세지 처리를 자유롭게)

⇒ 사실상 모든 OOP 장점의 근거이자 베이스

### 구현 방법

- 오버로딩
- 오버라이딩
- 함수형 인터페이스

다형성만으로 하나의 주제

<br>

# 끝난줄 알았지?

### ~~class =~~ 객체지향

### 목적

도움(2), 공유

### 나
