# 6일차

생명주기 함수에는 async 붙일 수 없어서 future 를 반환하는 비동기 함수와 같은 경우는 then으로  future 를 해제하거나 아니면 별도의 함수로 빼내서 함수를 안에서 실행시키던가 해야 한다

go router를 사용시 hero 위젯에 대한 애니메이션이  안먹는 경우도 있다. 그때는 네이게이션 사용해야 한다.

상황에 따라서  go router 네이게이션 섞어서 써야 하는 경우도 있음

## **MVVM 패턴**

규모가 커질수록

Repository 를 추상화하는

비즈니스 로직 클래스가 필요해짐

Repository 에서 비즈니스 로직 클래스가 별도로 빠져있으면  기능의 추가 및 변경을 할때 Repository 를 사용하는 화면에 영향도의 파급은 적으며 기능추가가 필요한 부분은 따로 모아져 있어서 좀 더 유지 보수에 대한 대응이 빠르다.

MVVM

Model -                          View                                    - ViewModel
(전체 데이터에 관한)           (화면)                               (특정 화면에 특화된 로직이 들어 있는 모델)



ViewModel 의 역할

- 모델(일반적으로 Repository)에서 제공한 데이터를 UI로 표시하기 쉬운 형태로 변환해 주는 역할 (복잡한 로직을 숨겨주는)
- 여러가지 상태(변수)를 캡슐화
    - 화면에 표시할 데이터
    - 로딩 상태 등
- View 에서 발생하는 액션(이벤트) 처리의 캡슐화

**ViewModel은 단지 화면(View) 하나에 대한 로직(Model) 일 뿐**

**→** 하나의 화면(View)에 하나의 ViewModel 이 일반적이다. 하지만 상황에 따라서 변동적인 부분이 있다.

ViewModel 안에 있는 메서드는 기본적으로  void이고 데이터의 반환은 getter에서 이루어 진다고 함

---

**ChangeNotifier** 

→ 관찰가능한 개체가 되게 하는 코드 조각이라고 생각해라

notifyListeners() 를 호출하여 변경사항을 알림(값이 변경되는 로직안에서 호출함)

데이터 바인딩 구현의 핵심

화면이 종료될 때 구독을 제거 (잊게되면 메모리 Leak이 발생될 수 있음)

화면에서 변수 있던 변수는  mvvm구조로 바뀌면서  view-model 로 이동 했다 또한 변수에 대한 상태 관리를 한다 그래서 화면에서 값 잘못되거나 값이 바뀌지 않는 경우 view-model로 에서 

레포지토리에서 바로 화면으로 이동하는 것에서 레포지토리과 화면의 중간에 역활로

화면에 적합하게 데이터가 담겨져서 화면에 데이터를 준다.

한마디로 service 와 자바스크립트 역할 가지고 간다.
