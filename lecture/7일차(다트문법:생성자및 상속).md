# 7일차

## 생성자

변수선언시  late 붙일 경우 늦은 초기화

late가 있는 경우 다트문법 대격변 시 오류나는 경우(nullable아닌데 아직 값 할당않은 경우) 대처하기 위해서 나온거다. 함부로 쓰면  오류의 가능성이 있다.

```dart
late String name;
```

map 에서  dynamic 쓰는 경우는 어쩔 수 없다.

기본적으로 프라이빗 변수는 required named 파라미터를 사용할 수 없다. 그러나 예외가 있다.

아래 생성자 코드에서 보면 생성자의 몸체(맨뒤에 {}중괄호 )안에 있는 것은 런타임에 실행되는 코드여서  nullable에 값이 할당된다고 보장할 수 없어서 컴파일러에서 오류남 이것을 해결하기 위해서 생성자의 :( 생성자 몸체 안앞에 있는 :는 이니셜라이즈 리스트표시임) 즉 이니셜라이즈 리스트까지 

생성자로 인식이 되기 때문에 해당 부분에서 값을 할당하면 프라이빗 변수라도 required named 파리미터로 사용가능하다. 

```dart
  Person(name2,{required String name, required int birthYear}): this._name2= name2 {
    this._name = name;
    this._birthYear = birthYear;
    this._age = now.year - birthYear;
  }
```

```dart
String _name

Persion({required String name}): _name = name //프라이빗이더라도 이니셜라이즈 리스트에 
                                              // 값할당해서 값을 넣어주는것을 보장시
                                              // 생성자에 required named 파라민터를 
                                              // 사용하는 것이 가능하다
                                              // : 이니셜라이즈 리스트 까지 생성자로
                                              // 인정되서이다.

```

참고로 setter 나 getter 멤버변수와 이름을 똑같이 만들어야 기존코드와 충돌 예방가능하다.

getter를 프로퍼티로 지칭한다.프로퍼티는 final 로 고정된 값이 아니기 때문에 작성된 코드에 따라 반환되는 값은 바뀔수 있다.

다트는 명시적으로 생성자 오버로드를 지원하지 않으나 생성자에 의미를 부여하기위헤서 named생성자를 추가로 만들 만들 수 있다. 

```dart
//클래스정의
Person.haha() : name = '하하' , birthYear = 2000;

//main에서 객체생성시 named생성자이용하는 경우 다만 스태틱 함수와 사용방법이 비슷하여
// 두개의 구분은 코드를 확인해봐야 한다.
final haha = Person.haha();

```

---

## 상속

> “이전에 만든 클래스와 닮았지만, 일부 다른 클래스"를 만들 필요가 있을 경우가 늘어날 것이다.
> 

상속은 extends 키워드와 뒤에 확장의 기반이 되는 클래스를 명시하면서 사용한다

상속받은 클래스는 상속이 기반되는  super클래스의 생성자를 호출해야하는 제약이 있다.

```dart
class SuperHero extends Hero{
   
   SuperHero({required super.name, required super.hp });// super클래스 생성자 호출
                                                        // 이와같은 상황 강제됨  
                                                           
}
```

위의 코드를 정확히 설명하자면 SuperHero 자체는 super클래스의 의 생성자는 아니다 다만 super.name과 super.hp 등 슈퍼 클래스의  생성에 필요한 데이터를 넣어줌으로써 맥락적으로  super의 생성자의 역활을 하기 때문에 위와 같은 표현을 썼다. 다만 현재 클래스에서 맴버변수의 값을 생성자에서 초기화 해주어야 할 경우 우리가 이전에 배웠던것처럼( this.멤버변수 초기화 해주었던것 처럼 )로 생성자에서 초기화 해주면 된다.    

다중상속은 Dart에서 금지 

오버라이드(override)

상속받은 클래스의 메소드를 재정의 하는 것 아래와 같이 메소드 위에 어노테이션으로 명시해준다.

```dart
@override
void run(){
}
```

부모 객체를 참조하는 super 키워드

```dart
@override
void run(){
	super.run(); // super클래스의 run메소드를 실행
	print('더 빠르게'); // 자기 자신 로직 추가
}
```

위와같이 작성하는 이유는 super클래스의 run에서 추가적인 로직을 작성하기 위해서이다.

> 잘못된 상속
> 
> 
> 현실 세계의 등장인물 사이에 **개념적으로 is-a 관계가 되지 못 함에도 불구하고 상속을 사용한 경우가 “잘못 된 상속"** 이다.
> 
> 예) 필드로 이름과 가격을 가지는 Item 클래스 (약초, 포션) 를 상속 받는 House
> 

> **잘못된 상속을 하면 안 되는 이유**
> 
> - 클래스를 확장할 때 현실세계와의 모순이 생긴다
> - 객체 지향의 3대 특징 중 1가지 “다형성" 을 이용할 수 없게 된다
> 
> House 가 Item을 상속 받았다면, House를 던질 수 있다.
> 
> ```dart
> class Item{
> 	int getDamage(){
> 		return 10;
> 	}
> }
> ```
> 
> 하지만 현실세계에서**집을 던지는 것은 어렵다**
> 

**구체화와 일반화의 관계**

자식클래스 일 수록 **구체화** 되고, 부모 클래스 일 수록 **추상적**인 것으로 **일반화** 된다.

![Untitled](https://github.com/happysong3914/TIL/assets/130008915/546d3638-4902-4f61-a837-74bc485bbc55)

> **정리**
> 
> 
> 상속의 기초
> 
> - extends를 사용하여 기존 클래스를 기초로 하는 새로운 클래스를 정의 할 수 있다
> - 부모 클래스의 멤버는 자동적으로 자식 클래스에 상속되므로, 자식 클래스에는 추가 된 부분만 기술 하면 된다
> - 부모 클래스에 있는 메소드를, 자식 클래스에서 재작성 할 경우 이것을 오버라이드 한다고 한다
> - 올바른 상속이란 “자식 클래스 is-a 부모 클래스"
> - 상속에는 “추상적, 구체적" 관계에 있다는 것을 정의하는 역할도 있음
> 
> 인스턴스
> 
> - 인스턴스는 내부에 부모클래스의 인스턴스를 가지는 다중구조를 가진다
> - 보다 외측의 인스턴스에 속하는 메소드가 우선적으로 동작한다
> - 외측의 인스턴스에 속하는 메소드는 super 을 사용하여 내측 인스턴스의 멤버에 접근할 수 있다
> 
> 생성자 동작
> 
> - 다중구조의 인스턴스가 생성되는데, 자동적으로 가장 외측 인스턴스의 생성자가 호출 됨
> - 모든 생성자는, “부모 인스턴스의 생성자"를 호출 할 필요가 있다
