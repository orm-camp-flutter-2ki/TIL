## 다형성

> 다형성 (polymorphism)
> 
> 
> **어떤 것을 이렇게도 볼 수 있고, 저렇게도 볼 수 있는 것**
> 
> 예:
> 
> 핸들이 있고, 오른 페달이 액셀, 왼쪽이 브레이크인 것 = 차, 그랜저, 버스 …
> 
> **세부적인 부분 부분은 다르지만, 어쨌든 대충 보면 그냥 차다**
> 

공통 행동에 대해서 인터페이스를 만들고 각각 해당 인터페이스에 대해서 상속을 하면 

인터페이스를 상속하게 된다면 해당 인터페이스를 참조변수로 선언하여 사용가능하다.

참조변수의 자료형은 컴파일러에게 이런 유형이란것을 알려주는 것이다.  그리고 컴파일러에게 

실제 객체가 어떤것인지는 안보인다. 그래서 컴파일러는 자신이 알고있는 참조변수의 자료형에 정의 되어 있는 것들(메소드 및 멤버변수들)밖에는 사용하지 못한다.  

다형성을 활용하는 방법은선언을 상위 개념으로 인스턴스 생성은 하위 개념으로 한다.

**추상적인 선언 = new 상세 정의**

```dart
Charcater character  = Hero('홍길동',100);
```

다형성을 사용하는 이유는 필요에 의해서 별도 다른 자료형의 객체를 기능별로 모으기 가능하고

그렇게 모은 객체들은 for문으로 같은 기능을 반복하여 수행할 수 있다.

```dart
	
	  Animal dog = Dog('개', '멍멍');
    Animal cat = Cat('고양이', '야옹');
    Animal bird = Bird('새', '끼룩');
    List<Animal> animal = [dog, cat, bird];

    for (int i = 0; i < animal.length; i++) {
      String sound = animal[i].makeSound();
      animal[i].move();
    }  
```

개발자가 직접 만든 클래스는 to자료형() 함수가 없기 때문에 타입캐스트를 하기 위해서는 as 로 

타입캐스트를 해야한다. as로 타입캐스팅하는 것이 위험한 이유는 as 로 타입캐스트하면 개발자가  잘못 캐스팅한것이라도 컴파일러는 개발자를 믿고 타입캐스트를 해서 런타임오류 발생가능

```dart
Animal dog = Dog('개', '멍멍');
Dog dag = dog as Dag
```

interface A

interface B

class C implements A , B

A a = C();

//B b = a 이코드는 실행되지 않는다 왜냐면 컴파일러는 단지 A 자료형이라고 인식해서

B b = a as C // 해당코드 실행가능하다 이유는 a가 가리키고 있는 실제 객체는 실제 B인터페이스를 구현하는 C라고 타입캐스트를 통해서 인식 시켜주어이다.                  

  

타입캐스트를 하는 이유는 추가 예로 들면 서로 연관성 없는 인터페이스(A,B)를 구현하는 클래스(C)를  생성하는데 참조변수를  인터페이스로 선언하여 생성(A)하면  해당 객체의 클래스에 실제로 해당 인터페이스를 구현하지만 컴파일러입장에서는 A인터페이스로 인식을 하기때문에 연관성없는 B인터페이스  자료형선언된 참조변수에 참조값을 넘겨주지 못한다고 판단해서 안된다.

그래서  안되는 것을 해결하기 위해서 실제 객체는 실제 B인터페이스를 구현하는 C라고 타입캐스트하여 컴파일러에게 해당 객체의 실제 자료형을 알려줌으로 써 해결 가능하다. 이것이 타입캐스트가 필요한 또 다른 이유이다.

다형성을 쓰는 이유는 여러 타입의 파라미터를 넣어야 하는 경우 넣어야하는  여러 파라미터 타입의 공통 조상 클래스로 함수의 파라미터의 자료형을 설정할 경우 이상없이 작동 가능 →기능확장이 쉬움

> 
> 
> 
> 인스턴스를 애매하게 퉁치기
> 
> - 상속에 의한 is-a 관계가 성립한다면, 인스턴스를 부모 클래스 타입의 변수에 대입할 수 있다
> - 부모 클래스 타입 변수에 대입하는 것으로, 퉁 칠 수 있음
> 
> **상자의 타입** 과 **내용의 타입** 의 역할
> 
> - 어떤 멤버를 이용할 수 있는가는 상자의 타입이 결정한다
> - 멤버가 어떻게 움직이는지는 내용의 타입이 결정한다
> 
> 취급 변경
> 
> - as 키워드를 사용하여 타입 캐스팅을 수행한다
> - is 키워드를 사용하여 타입을 검사할 수 있다
> 
> 다형성
> 
> - 같은 부모를 가지는 다른 인스턴스를 동일시하여, 부모 클래스 타입의 에 담을 수 있다
> - 마찬가지로, 부모 클래스 타입의 인수나 리턴 값을 이용하여, 다른 클래스를 모아서 처리 가능
> - 동일시 취급 해도, 각각의 인스턴스는 각 클래스의 정의를 따르고 다른 동작을 한다.
