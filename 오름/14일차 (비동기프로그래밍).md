## [비동기 프로그래밍]

- **다른 작업**이 **완료**되기를 기다리는 동안 **프로그램**이 **작업**을 **완료**하는 프로세스
- **네트워크**를 통해 **데이터**를 가져오거나, **데이터 베이스**에 **쓰기**(**write**)를 **수행**하거나 **파일**로 부터 **데이터**를 읽을 때(**read**), **유저**의 **응답**을 기다려야 하는 경우 등 **비동기 작업**을 수행
- 비동기는 현재 코드의 **실행 결과를 받지 않고** 이후 코드를 수행하는 기법
- 이러한 **비동기 작업**의 **결과**를 보통 **Future**로 **제공**

### cf. 동기(sync) 프로그래밍

코드가 순차적으로 실행되며, 한 번에 하나의 작업만을 처리하는 방식

→ 한 번에 하나의 작업만을 처리하기 때문에 CPU 및 기타 자원을 효율적으로 활용하지 못할 수 있음

### cf. 콜백함수(callback function)

-다른 함수에 인자로 전달되어 나중에 호출되는 함수를 말함. 일반적으로 비동기적인 상황에서 사용되며, 비동기 작업이 완료되었을 때 실행되는 작업을 정의할 때 주로 활용

(현실 세계에서 콜백의 예시 : 음식을 주문하고 진동벨을 가지고 기다리면 음식이 준비되면 손님을 호출(Callback)하는 상황⇒즉 기다렸다가 알림을 받는 것)

# [Future 함수]

**Future**는 **미래의 값**을 나타내는데, 이 값은 **작업**이 **완료된 후**에 **반환**되는 것을 의미.

```jsx
ex)
Future<String> name;  // 미래에 값이 string으로 넘어오겠다.
Future<int> number;   
Future<Person> person; 
```

### **1. async 함수 선언하기**

async 키워드를 함수 앞에 붙여 비동기 함수를 선언

Future 함수는 함수 본문 앞에 **async** 키워드를 지정해 줘야 한다. **짝꿍임!!!**

```dart
Future<void> saveDb(user) async{
print('saving $user to db');
}

Future<String> getResult(user) async {
return 'success register $user';

return이 없으면 void라고 쓰고, return이 있으면 값을 써줘야됨.
async 키워드랑 같이 선언이 되어 있어야 함.
```

## 2. await

비동기 작업이 완료될 때까지 코드 실행을 일시 중지하고 비동기 작업이 완료되면 그 결과를 반환하거나 예외를 발생시킴.

**대기하고 싶은 비동기 함수**를 실행할 때 **await** 키워드를 사용해주면 코드를 작성한 **순서대로 실행.**

즉, 코드를 순차적으로 작성하고 비동기 작업의 결과를 처리하는 데 사용되며, 

```dart
 print('시작');
 final delay = Future.delay(duration(second: 5));
 print('끝);
 
 =>delay는 생성자. Future라는 것을 만드는 생성자임.
 2초동안 delay를 주는 코드.
 시작과 끝이 먼저 실행이 되고 나중에 비동기로 5초 뒤에 끝남
```

**⇒에러처리:** async - await 쓰고 try-catch로 조합해 쓰기

## **3. then()**

future객체의 메서드로, future가 완료될 때 수행할 작업을 지정함.

then() 함수로 전달되는 콜백 함수에 다음에 실행할 코드를 작성하면 된다.

다음 코드가 Future라면 계속해서 then() 을 이어서 결과를 전달받을 수 있다.

```dart
final user = {
 'email': 'abc@abc.com',
 'password': '123456',
  'name': 'john doe',
  };
  
  saveDb(user)
    .then((_) => sendEmail(user))
    .then((_) => getResult(user))
    
    
 앞에 있는 함수가 끝났을 때 호출되는 콜벡
 save가 끝나면 sendEmail이 호출되고, 그 다음 future 함수 실행하고,
 또 이게 끝나면 getResult가 호출이 됨.
```

**⇒ then()사용 문제점:**

- 확실히 콜백 보다는 편하지만 동기식 코드 보다는 결과 예측이 어렵다.
- 단계가 많아지면 then() 을 연결하는 체이닝 방식을 사용하는 것이 만만치 않다.
- 로직이 복잡해 지면 적절한 예외처리하기에 용이하지 않다.
  

## **<결 론 - async - await 이거 써라~~>**
