# 0308 5일차

## 1. 코드 정리

1) 코드 정리 하기(ctrl+Alt+L)

2) 띄어쓰기 잘 하기

3) 변수 이름은 의미있게

4) 가독성 좋게 → ex) 상수 / 변수 나누어서 잘 배치하기

---

## 2. final

-프로그램의 특정 부분이 변경되지 않도록 하거나, 불변성을 보장하기 위해 사용

-이것은 변수, 메서드 또는 클래스에서 사용 가능함.

-한 번 값이 할당되면 변경할 수 없음을 의미

-런타임에 값을 할당할 수 있지만 이후에는 변경할 수 없음. final 변수의 값을 런타임에 지정할 수 있으므로 실행 중에 초기화될 수 있음. 즉 선언과 동시에 값을 할당하는 것.

1. **변수에 대한 불변성 보장**: 변수를 final로 선언하면 해당 변수의 값이 한 번 설정되면 변경되지 않음을 의미함. 이는 코드의 가독성을 높이고 예기치 않은 상태 변경을 방지. 또한 다른 개발자가 코드를 이해하고 유지 관리하기 쉽도록 함.
2. **메서드 오버라이딩 방지**: 메서드를 final로 선언하면 하위 클래스에서 해당 메서드를 오버라이드할 수 없음. 이는 상위 클래스의 기능이 하위 클래스에서 변경되지 않도록 보장하며, 코드의 안정성과 예측 가능성을 높임.
3. **클래스 상속 방지**: 클래스를 final로 선언하면 해당 클래스를 상속할 수 없음. 이는 클래스의 기능이 변경되지 않도록 보장하고, 클래스의 불변성을 유지하는 데 도움이 됨.

### cf. const

-컴파일 시간에 상수를 정의하는 데 사용.

-const는 변수가 컴파일 시간에 상수로 평가되도록 보장. 

-따라서 final은 런타임에 값을 할당하고 변경할 수 없는 변수를 정의하는 데 사용되고, 
const는 컴파일 시간에 상수로 평가되는 변수를 정의하는 데 사용됨.

**⇒ 지금은 final 위주로 쓸것!!**

```dart
ex)
void main() {
final me = Hero(name: '김씨', hp: 100);
final you = me;
final father = me;
}

현실세계에 '나'라는 인스턴스가 있는 것임.
final이 의미하는 것은 '김씨'라는 사람임. 
즉, 속성이나 존재가 변하는게 아니라
그냥 이를 부르는 명칭(이름)이 바뀔 뿐임. (너라든지, 아빠라든지)

만약에 결혼 상대가 바뀐다면?
var husband = Hero(name: '김씨', hp: 200)
이렇게 변할 수 있는 것.
```

---


## 3. 레퍼런스 타입과 참조

Dart 는 모든 타입이 레퍼런스 타입

- 가상세계 = 컴퓨터의 메모리 영역
- 인스턴스 = heap 영역 안에 확보된 메모리


(뒤에 나올 static에 저장되는 것은 heap에 저장되지 않음.
그래서 인스턴스가 static에 접근하지 못하는 것임.!)

---


## 4. 인스턴스: Hero 클래스를 인스턴스화 하여 이용 하는 코드

```dart
final hero = Hero(name: '홍길동', hp: 100);
```

final 옆에 hero 히어로에다가 인스턴스를 저장함. 

이 hero에 정보를 담고 있는 메모리 주소가 hero에 들어감.

---

## 5. 두 개의 Hero 형 변수

```dart
final hero1 = Hero(name: '홍길동', hp: 100);
final hero2 = hero1;  //메모리 주소가 같음
hero.hp = 200;
```

---


## 6. required: Sword 형 필드를 가지는 클래스

- required는 필수의 의미!!!


```dart
class Hero {
 String name;
 int hp;
  Sword? sword; // 칼이 없을수도 있음. 그래서 null? 을 쓰는 것.
  
  Hero({
   required this.name,
   required this.hp,
   this. swrod,
   });

  
```

   
   ** required 키워드는 해당 매개변수가 반드시 필요하며, 호출할 때 반드시 값을 전달해야 함을 나타낸다.즉, 해당 매개변수는 선택적(optional)이 아니라 필수적(required)임. 예를 들어, Hero 클래스의 생성자에서 name과 hp는 반드시 필요한 매개변수이기 때문에 required 키워드가 사용.
이 매개변수들은 객체를 생성할 때 반드시 값을 전달해야 함.  반면에 sword는 선택적(optional) 매개변수로서 값을 전달하지 않아도 되며, 전달하지 않을 경우 기본값은 null이 된다.

---

## 7. 생성자(constructor): 클래스 안에 있는 함수.

우리가 설계도를 이용해서 만든 인스턴스의 신상 정보를 받아서 초기화 시켜주는 역할을 한다. 

즉, 클래스의 인스턴스를 초기화하기 위한 특별한 메서드.

```dart
class Wizard
 String name;
 int hp;
 
 **Wizard(this.name, this.hp);**
```

---

## 8. 필수 파라미터와 named(=옵셔널)파라미터

```dart
class Hero {
String name;
int hp;
Sword? sword;

//필수 파라미터와 옵셔널 파라미터를 동시에 사용할 수 있다.
Hero(this.name, this.hp, {this.swrod});

여기서 sword는 옵션임. 있어도 되고 없어도 되고
이런걸 조절할 수 있는게 생성자임. 내 마음대로 조절.
필수 parameter와 named parameter를 동시에 사용할 경우 필수 parameter가 앞에 와야 함
마지막 파라미터 뒤에 콤마를 찍을 수 없음.
```


```dart
final hero1 = Hero(name: '슈퍼맨', hp: 100); //이것이 네임드 파라미터. 
```

* 필수 파라미터vs네임드 파라미터
final hero2 = Hero('검사', 100, sword: sword);
              이거는 필수파라미터 / 뒤에 sword:sword는 네임드 파라미터 => 무조건 순서대로 해야됨! 규칙 (필수 먼저, 뒤에는 네임드!!)

## 9. 생성자의 오버로드 (Constructor Overloading)

생성하는 방법을 여러개를 제공한다는 뜻.

**생성자 오버로드란** 클래스 내에서 여러 개의 생성자를 정의하는 것을 말한다. 이러한 생성자들은 서로 다른 매개변수 목록을 가질 수 있음. 
예를 들어, 하나의 클래스에서 여러 가지 방법으로 객체를 생성할 수 있도록 여러 개의 생성자를 제공할 수 있음. 이러한 생성자 오버로딩은 객체를 생성할 때 다양한 상황에 맞게 유연하게 대응할 수 있도록 도와준다.

생성자에 들어가는 파라미터, 메소드에 들어가는 파라미터가 다른데

**고려해야 될 것은? 순서가 필수냐 선택이냐가 제일 중요함. 필수면 required 들어가야되고, 정해진 순서대로 들어가야 됨.

## 10. static

공유자원. 클래스 멤버를 정의할 때 사용. 이 키워드를 사용하여 정의된 멤버는 해당 클래스의 인스턴스와 연결되지 않고 클래스 자체에 연결. 이것은 클래스의 모든 인스턴스가 동일한 값을 공유하게 만듦. 
일반적으로 클래스의 인스턴스에 속하는 필드나 메서드는 각각의 인스턴스에 대해 독립적으로 존재.
즉, 클래스의 각 인스턴스는 자체적인 상태를 가진다. 그러나 `static`으로 표시된 필드나 메서드는 클래스 자체에 속하며 클래스의 모든 인스턴스에 대해 동일한 값을 공유하거나 동일한 동작을 수행.

```
class Hero {
static int money = 100;  // ex) 4명 파티원이 같은 자원을 나눠쓰게됨.
String name;
int hp;
Sword? sword;
