### 지난 과제리뷰)

- **1. Late는 쓰지말자.**

```dart
ex)
class wand {
 String name;
 late double
 
 //오류 날 것. why? 값을 초기화하지 않았기 때문임.
```

Q 값을 초기화하는 이유: 객체가 생성될 때 각 필드가 초기 상태를 가져야하기 때문임. 객체가 생성되면 해당 필드는 어떤 값으로든 초기화되어야 함! 값이 초기화되지 않은 상태로 필드에 접근하려고 하면 예상치 못한 동작이 발생할 수 있다. 또한 값의 초기화는 객체의 무결성을 유지하는 데 도움이 되고  필드가 초기화되면 해당 필드에 대한 불변성과 유효성을 보장할 수 있음. 

- **2. 최대한 지양할 것**

 ① var

 ② name!(nullable인 객체를 nullable 아니게 하는것(=강제 널러블)

 ③  late (변수를 초기화 선언만하고 초기화는 지금이 아닌 나중에 초기화하고 싶을 때 사용)

 ④ dynamic (Map에서만 예외로 허용)  

```dart
ex)
String getNmae() => '홍길동';

getNmae() => '홍길동'
->이런거 최대한 지양. 왜냐? 앞에 dynamic으로 임의로 정해지기 때문에.
그니까 앞에 웬만하면 String처럼 데이터타입 구체적으로 적어주는 것이 좋음.
```

- **3. Initializer list(이니셜라이즈 리스트)**

다트에서 List를 초기화하는 방법 중 하나로 사용.

이니셜라이즈 리스트는 리스트를 선언하고 동시에 초기값을 할당하는 방식임

⇒ 이를 통해 코드를 간결하게 작성할 수 있음.
(dart문서 참조: [Constructors | Dart](https://dart.dev/language/constructors#initializer-list))

```dart
class wand {
 String _name;
 double power;
 
 Wand({
  required String name,
  required this.power,
  }) : _name = name;
  }
```

- **4. Named constructors**

다트에서 특별한 종류의 생성자로서, 클래스 내에서 다른 생성자와 구별하기 위해 이름을 가지는 생성자. 네임드 생성자는 클래스의 인스턴스를 생성하는데 사용되며, 클래스 이름 뒤에 마침표(.)와 생성자의 이름을 붙여 사용함.

*문서 참조: **https://dart.dev/language/constructors#named-constructors**

---



# [상속(inheritance)]

상속은 한 클래스가 다른 클래스의 속성과 동작을 물려받는 것을 의미

-쓰는이유: 실수 방지,,

```dart
class SuperHero extends Hero {
SuperHero({required super.name, required super.hp}); // 슈퍼의 생성자를 호출하는 코드.

class SuperHero extends **Hero** 
        ㄴsuperHero는 이것은 서브클래스 히어로, 
                          ㄴHero 이거는 슈퍼클래스 히어로
                          
 class SuperHero extends **Hero** { 여기서 alt+enter 눌러서 생성자 호출해줌
  SuperHero({required super.name, required super.hp,});} <-자동으로 호출됨 
  
  이렇게 하면 기존의 'Hero'파일에 있던 기능들.. hp나 sword나 등등도 다 사용할 수 있게 됨
```

### 1. 상속관계의 표현 방법

- 만약 Hero가 중심, SuperHero는 덧붙여 지는것. (코드 작성할때 그림 고려)
- Hero ← SuperHero로 가는 다이어그램임.

- **다이어그램 참고: [클래스 다이어그램 구문 및 기능](https://plantuml.com/ko/class-diagram)

### 2. 올바른 상속의 설계방법 (=is a)

is - a 원칙: 슈퍼히어로는 hero다.

이것에 반하면 다 잘못된 상속임.

```dart
ex)
import 'king.dart';

class Inn extends King {
 void checkInn(Hero hero){
 hero.hp = 100;
 }
 
 이것은 말이 안되므로 맞지 않은 코드임. 호텔이랑 왕? 현실세계랑 맞지 않으니까.
 즉, 현실 세계의 등장인물 사이에 개념적으로 is-a 관계가 되지 못함에도 불구하고
 상속을 사용한 경우 -> 모순이 생김
```

### 3. 슈퍼클래스와 서브클래스의 구분

슈퍼클래스: person / 서브클랙스: student (O)

슈퍼클래스: CAR / 서브클래스: Engine (X) 


### 4. 구체화와 일반화의 관계

자식클래스일 수록 구체화되고, 부모클래스 일수록 추상적인 것으로 일반화된다.

### 5. 오버라이드

오버라이드: 재정의. ex) hero안의 메소드를 재정의

cf. 다트는 오버로드 지원하지 않음. 

개념: 부모 클래스에서 정의된 메서드나 프로퍼티를 자식 클래스에서 다시 정의하는 것을 말함.

즉, 자식 클래스에서 부모 클래스의 동일한 이름을 가진 메서드나 프로퍼티를 재정의하여 자식 클래스의 동작을 변경하거나 확장할 수 있다.

ex) 부모 클래스인 'Animal' 클래스에는 'makeSound()' 메서드가 있다고 가정해 보자. 그리고 이 클래스를 상속받는 자식 클래스인 'Cat' 클래스에서 'makeSound()' 메서드를 오버라이드하여 고양이의 소리를 출력하도록 변경할 수 있다.


---

### *[해결 안된 내용: 챗 gpt랑 공부..]*
### 1. getter와 setter 사용 이유와 차이?
>
>게터(Getter)와 세터(Setter)는 객체지향 프로그래밍에서 클래스의 속성에 접근하거나 값을 설정하는 메서드입니다. 이 둘은 클래스의 캡슐화(encapsulation)를 유지하고 객체의 상태를 제어하는 데 사용됩니다. 
>
>당신은 집을 갖고 있습니다. 그 집 안에는 몇몇 소중한 물건들이 있습니다. 이 소중한 물건들은 모두 잠긴 서랍 안에 보관되어 있습니다. 여러분은 방문자에게 집 안의 물건에 접근할 수 있도록 할 것인가요? Getter와 setter는 이런 상황에서 사용됩니다. 
>
>Getter는 마치 방문자에게 소중한 물건을 전달하는 역할을 합니다. 방문자는 집 안에 있는 물건에 대한 정보를 요청할 수 있지만 직접적으로 접근할 수는 없습니다. 이때 Getter는 요청된 정보를 반환합니다. 
>
>Setter는 반대로 방문자에게 집 안에 있는 물건을 변경하거나 추가할 수 있는 권한을 줍니다. 하지만 방문자가 직접적으로 물건을 가져갈 수는 없으며, Setter를 통해 요청된 변경사항이 유효한지 확인하고 진행합니다.
>
>이렇게하면 집의 주인은 방문자가 집 안의 물건에 손상을 줄 가능성을 최소화할 수 있습니다. 이것이 Getter와 Setter가 왜 사용되는지에 대한 간단한 비유입니다.
>
>1) **기능**:
>  - 게터(Getter): 클래스의 속성 값을 읽는 데 사용됩니다. 보통 속성의 현재 값을 반환합니다.
>  - 세터(Setter): 클래스의 속성 값을 설정하거나 변경하는 데 사용됩니다. 보통 속성에 새로운 값을 할당합니다.
>2) **문법**:
>  - 게터(Getter): 메서드 이름 앞에 **`get`** 키워드를 사용하여 정의됩니다.
>  - 세터(Setter): 메서드 이름 앞에 **`set`** 키워드를 사용하여 정의됩니다.
>3) **호출 방식**:
>  - 게터(Getter): 일반적으로 속성 이름을 호출하면 자동으로 호출됩니다. 즉, **`obj.property`** 형태로 호출됩니다.
>  - 세터(Setter): 값을 설정할 때 사용됩니다. 즉, **`obj.property = value`** 형태로 호출됩니다.
>4) **사용 방법**:
>  - 게터(Getter): 클래스의 내부 상태를 읽거나 계산된 값을 반환할 때 사용됩니다. 예를 들어, 반지름 속성을 가진 Circle 클래스에서 원의 넓이를 게터로 계산하여 반환할 수 있습니다.
>  - 세터(Setter): 클래스의 속성 값을 변경할 때 사용됩니다. 예를 들어, 사각형의 너비와 높이를 변경할 때 세터를 사용하여 새로운 값을 설정할 수 있습니다.
>
### 2. required

>required: 필수 매개변수. 반드시 값을 가져야 함
>이 키워드가 없으면 선택적(optional)으로 값을 가진다!
>
>(따라서 name 매개변수는 required로 지정되었으므로 반드시 값을 가져야 하고, 반면 power 매개변수는 required 키워드를 사용하지 않았으므로 선택적(optional)임. 즉, power의 경우 명시적으로 값을 전달하지 않아도 됨. 대신에 초기화 리스트(initialization list)에서 직접적으로 매개변수를 받아들이고, 이를 인스턴스 변수에 할당함. 그러므로 name은 생성자에 필수적으로 필요한 매개변수이며, power는 선택적(optional) 매개변수다.)
